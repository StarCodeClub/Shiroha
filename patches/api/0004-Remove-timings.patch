From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Wed, 21 Dec 2022 20:50:34 +0800
Subject: [PATCH] Remove timings


diff --git a/src/main/java/co/aikar/timings/FullServerTickHandler.java b/src/main/java/co/aikar/timings/FullServerTickHandler.java
deleted file mode 100644
index dfaa266ff53e43ad48dc5a5a5657fe70600f539a..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/FullServerTickHandler.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package co.aikar.timings;
-
-import static co.aikar.timings.TimingsManager.*;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-
-public class FullServerTickHandler extends TimingHandler {
-    private static final TimingIdentifier IDENTITY = new TimingIdentifier("Minecraft", "Full Server Tick", null);
-    final TimingData minuteData;
-    double avgFreeMemory = -1D;
-    double avgUsedMemory = -1D;
-    FullServerTickHandler() {
-        super(IDENTITY);
-        minuteData = new TimingData(id);
-
-        TIMING_MAP.put(IDENTITY, this);
-    }
-
-    @NotNull
-    @Override
-    public Timing startTiming() {
-        if (TimingsManager.needsFullReset) {
-            TimingsManager.resetTimings();
-        } else if (TimingsManager.needsRecheckEnabled) {
-            TimingsManager.recheckEnabled();
-        }
-        return super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        super.stopTiming();
-        if (!isEnabled() || Bukkit.isStopping()) {
-            return;
-        }
-        if (TimingHistory.timedTicks % 20 == 0) {
-            final Runtime runtime = Runtime.getRuntime();
-            double usedMemory = runtime.totalMemory() - runtime.freeMemory();
-            double freeMemory = runtime.maxMemory() - usedMemory;
-            if (this.avgFreeMemory == -1) {
-                this.avgFreeMemory = freeMemory;
-            } else {
-                this.avgFreeMemory = (this.avgFreeMemory * (59 / 60D)) + (freeMemory * (1 / 60D));
-            }
-
-            if (this.avgUsedMemory == -1) {
-                this.avgUsedMemory = usedMemory;
-            } else {
-                this.avgUsedMemory = (this.avgUsedMemory * (59 / 60D)) + (usedMemory * (1 / 60D));
-            }
-        }
-
-        long start = System.nanoTime();
-        TimingsManager.tick();
-        long diff = System.nanoTime() - start;
-        TIMINGS_TICK.addDiff(diff, null);
-        // addDiff for TIMINGS_TICK incremented this, bring it back down to 1 per tick.
-        record.setCurTickCount(record.getCurTickCount()-1);
-
-        minuteData.setCurTickTotal(record.getCurTickTotal());
-        minuteData.setCurTickCount(1);
-
-        boolean violated = isViolated();
-        minuteData.processTick(violated);
-        TIMINGS_TICK.processTick(violated);
-        processTick(violated);
-
-
-        if (TimingHistory.timedTicks % 1200 == 0) {
-            MINUTE_REPORTS.add(new TimingHistory.MinuteReport());
-            TimingHistory.resetTicks(false);
-            minuteData.reset();
-        }
-        if (TimingHistory.timedTicks % Timings.getHistoryInterval() == 0) {
-            TimingsManager.HISTORY.add(new TimingHistory());
-            TimingsManager.resetTimings();
-        }
-        Bukkit.getUnsafe().reportTimings();
-    }
-
-    boolean isViolated() {
-        return record.getCurTickTotal() > 50000000;
-    }
-}
diff --git a/src/main/java/co/aikar/timings/TimedEventExecutor.java b/src/main/java/co/aikar/timings/TimedEventExecutor.java
index 4e6e1b8e8aeb07e34536941d2cbfc25e5cfa6c27..9189727642b7f366750249d2f0563dd388b42b7e 100644
--- a/src/main/java/co/aikar/timings/TimedEventExecutor.java
+++ b/src/main/java/co/aikar/timings/TimedEventExecutor.java
@@ -66,8 +66,7 @@ public class TimedEventExecutor implements EventExecutor {
 
         final String eventName = eventClass.getSimpleName();
         boolean verbose = "BlockPhysicsEvent".equals(eventName);
-        this.timings = Timings.ofSafe(plugin, (verbose ? "## " : "") +
-            "Event: " + id + " (" + eventName + ")");
+        this.timings = Timings.NULL_HANDLER;
     }
 
     @Override
diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
index 199789d56d22fcb1b77ebd56805cc28aa5a5ab0a..e9b1f26744324656fd010703eb0863dc538f222a 100644
--- a/src/main/java/co/aikar/timings/TimingHandler.java
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -38,189 +38,41 @@ import org.jetbrains.annotations.Nullable;
 
 class TimingHandler implements Timing {
 
-    private static AtomicInteger idPool = new AtomicInteger(1);
-    private static Deque<TimingHandler> TIMING_STACK = new ArrayDeque<>();
-    final int id = idPool.getAndIncrement();
-
-    final TimingIdentifier identifier;
-    private final boolean verbose;
-
-    private final Int2ObjectOpenHashMap<TimingData> children = new LoadingIntMap<>(TimingData::new);
-
-    final TimingData record;
-    private TimingHandler startParent;
-    private final TimingHandler groupHandler;
-
-    private long start = 0;
-    private int timingDepth = 0;
-    private boolean added;
-    private boolean timed;
-    private boolean enabled;
-
-    TimingHandler(@NotNull TimingIdentifier id) {
-        this.identifier = id;
-        this.verbose = id.name.startsWith("##");
-        this.record = new TimingData(this.id);
-        this.groupHandler = id.groupHandler;
-
-        TimingIdentifier.getGroup(id.group).handlers.add(this);
-        checkEnabled();
-    }
-
-    final void checkEnabled() {
-        enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
+    @NotNull
+    @Override
+    public Timing startTiming() {
+        return this;
     }
 
-    void processTick(boolean violated) {
-        if (timingDepth != 0 || record.getCurTickCount() == 0) {
-            timingDepth = 0;
-            start = 0;
-            return;
-        }
+    @Override
+    public void stopTiming() {
 
-        record.processTick(violated);
-        for (TimingData handler : children.values()) {
-            handler.processTick(violated);
-        }
     }
 
     @NotNull
     @Override
     public Timing startTimingIfSync() {
-        startTiming();
         return this;
     }
 
     @Override
     public void stopTimingIfSync() {
-        stopTiming();
-    }
-
-    @NotNull
-    public Timing startTiming() {
-        if (!enabled || !Bukkit.isPrimaryThread()) {
-            return this;
-        }
-        if (++timingDepth == 1) {
-            startParent = TIMING_STACK.peekLast();
-            start = System.nanoTime();
-        }
-        TIMING_STACK.addLast(this);
-        return this;
-    }
-
-    public void stopTiming() {
-        if (!enabled || timingDepth <= 0 || start == 0 || !Bukkit.isPrimaryThread()) {
-            return;
-        }
-
-        popTimingStack();
-        if (--timingDepth == 0) {
-            addDiff(System.nanoTime() - start, startParent);
-            startParent = null;
-            start = 0;
-        }
-    }
-
-    private void popTimingStack() {
-        TimingHandler last;
-        while ((last = TIMING_STACK.removeLast()) != this) {
-            last.timingDepth = 0;
-            if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Look above this for any errors and report this to Paper unless it has a plugin in the stack trace (" + last.identifier + " did not stopTiming)");
-            } else {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Report this to the plugin " + last.identifier.group + " (Look for errors above this in the logs) (" + last.identifier + " did not stopTiming)", new Throwable());
-            }
 
-            boolean found = TIMING_STACK.contains(this);
-            if (!found) {
-                // We aren't even in the stack... Don't pop everything
-                TIMING_STACK.addLast(last);
-                break;
-            }
-        }
     }
 
     @Override
-    public final void abort() {
-
-    }
-
-    void addDiff(long diff, @Nullable TimingHandler parent) {
-        if (parent != null) {
-            parent.children.get(id).add(diff);
-        }
-
-        record.add(diff);
-        if (!added) {
-            added = true;
-            timed = true;
-            TimingsManager.HANDLERS.add(this);
-        }
-        if (groupHandler != null) {
-            groupHandler.addDiff(diff, parent);
-            groupHandler.children.get(id).add(diff);
-        }
-    }
+    public void abort() {
 
-    /**
-     * Reset this timer, setting all values to zero.
-     */
-    void reset(boolean full) {
-        record.reset();
-        if (full) {
-            timed = false;
-        }
-        start = 0;
-        timingDepth = 0;
-        added = false;
-        children.clear();
-        checkEnabled();
     }
 
-    @NotNull
+    @Nullable
     @Override
     public TimingHandler getTimingHandler() {
-        return this;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        return (this == o);
+        return null;
     }
 
-    @Override
-    public int hashCode() {
-        return id;
-    }
-
-    /**
-     * This is simply for the Closeable interface so it can be used with try-with-resources ()
-     */
     @Override
     public void close() {
-        stopTimingIfSync();
-    }
-
-    public boolean isSpecial() {
-        return this == TimingsManager.FULL_SERVER_TICK || this == TimingsManager.TIMINGS_TICK;
-    }
 
-    boolean isTimed() {
-        return timed;
-    }
-
-    public boolean isEnabled() {
-        return enabled;
-    }
-
-    @NotNull
-    TimingData[] cloneChildren() {
-        final TimingData[] clonedChildren = new TimingData[children.size()];
-        int i = 0;
-        for (TimingData child : children.values()) {
-            clonedChildren[i++] = child.clone();
-        }
-        return clonedChildren;
     }
 }
diff --git a/src/main/java/co/aikar/timings/TimingHistory.java b/src/main/java/co/aikar/timings/TimingHistory.java
index 203cda0f9a4dea4f28a21ea9ee8db7a7369842e3..b342a3bdeae8f525cdabfc9979c38263702083fd 100644
--- a/src/main/java/co/aikar/timings/TimingHistory.java
+++ b/src/main/java/co/aikar/timings/TimingHistory.java
@@ -23,332 +23,11 @@
  */
 package co.aikar.timings;
 
-import co.aikar.timings.TimingHistory.RegionData.RegionId;
-import com.google.common.base.Function;
-import com.google.common.collect.Sets;
-import org.bukkit.Bukkit;
-import org.bukkit.Chunk;
-import org.bukkit.Material;
-import org.bukkit.World;
-import org.bukkit.block.BlockState;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Player;
-import co.aikar.util.LoadingMap;
-import co.aikar.util.MRUMapCache;
-
-import java.lang.management.ManagementFactory;
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-import static co.aikar.timings.TimingsManager.FULL_SERVER_TICK;
-import static co.aikar.timings.TimingsManager.MINUTE_REPORTS;
-import static co.aikar.util.JSONUtil.*;
-
 @SuppressWarnings({"deprecation", "SuppressionAnnotation", "Convert2Lambda", "Anonymous2MethodRef"})
 public class TimingHistory {
-    public static long lastMinuteTime;
-    public static long timedTicks;
-    public static long playerTicks;
-    public static long entityTicks;
-    public static long tileEntityTicks;
-    public static long activatedEntityTicks;
-    private static int worldIdPool = 1;
-    static Map<String, Integer> worldMap = LoadingMap.newHashMap(new Function<String, Integer>() {
-        @NotNull
-        @Override
-        public Integer apply(@Nullable String input) {
-            return worldIdPool++;
-        }
-    });
-    private final long endTime;
-    private final long startTime;
-    private final long totalTicks;
-    private final long totalTime; // Represents all time spent running the server this history
-    private final MinuteReport[] minuteReports;
-
-    private final TimingHistoryEntry[] entries;
-    final Set<Material> tileEntityTypeSet = Sets.newHashSet();
-    final Set<EntityType> entityTypeSet = Sets.newHashSet();
-    private final Map<Object, Object> worlds;
 
     TimingHistory() {
-        this.endTime = System.currentTimeMillis() / 1000;
-        this.startTime = TimingsManager.historyStart / 1000;
-        if (timedTicks % 1200 != 0 || MINUTE_REPORTS.isEmpty()) {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size() + 1]);
-            this.minuteReports[this.minuteReports.length - 1] = new MinuteReport();
-        } else {
-            this.minuteReports = MINUTE_REPORTS.toArray(new MinuteReport[MINUTE_REPORTS.size()]);
-        }
-        long ticks = 0;
-        for (MinuteReport mp : this.minuteReports) {
-            ticks += mp.ticksRecord.timed;
-        }
-        this.totalTicks = ticks;
-        this.totalTime = FULL_SERVER_TICK.record.getTotalTime();
-        this.entries = new TimingHistoryEntry[TimingsManager.HANDLERS.size()];
-
-        int i = 0;
-        for (TimingHandler handler : TimingsManager.HANDLERS) {
-            entries[i++] = new TimingHistoryEntry(handler);
-        }
-
-        // Information about all loaded chunks/entities
-        //noinspection unchecked
-        this.worlds = toObjectMapper(Bukkit.getWorlds(), new Function<World, JSONPair>() {
-            @NotNull
-            @Override
-            public JSONPair apply(World world) {
-                Map<RegionId, RegionData> regions = LoadingMap.newHashMap(RegionData.LOADER);
-
-                for (Chunk chunk : world.getLoadedChunks()) {
-                    RegionData data = regions.get(new RegionId(chunk.getX(), chunk.getZ()));
-
-                    for (Entity entity : chunk.getEntities()) {
-                        if (entity == null) {
-                            Bukkit.getLogger().warning("Null entity detected in chunk at position x: " + chunk.getX() + ", z: " + chunk.getZ());
-                            continue;
-                        }
-
-                        data.entityCounts.get(entity.getType()).increment();
-                    }
-
-                    for (BlockState tileEntity : chunk.getTileEntities(false)) {
-                        if (tileEntity == null) {
-                            Bukkit.getLogger().warning("Null tileentity detected in chunk at position x: " + chunk.getX() + ", z: " + chunk.getZ());
-                            continue;
-                        }
-
-                        data.tileEntityCounts.get(tileEntity.getBlock().getType()).increment();
-                    }
-                }
-                return pair(
-                    worldMap.get(world.getName()),
-                    toArrayMapper(regions.values(),new Function<RegionData, Object>() {
-                        @NotNull
-                        @Override
-                        public Object apply(RegionData input) {
-                            return toArray(
-                                input.regionId.x,
-                                input.regionId.z,
-                                toObjectMapper(input.entityCounts.entrySet(),
-                                    new Function<Map.Entry<EntityType, Counter>, JSONPair>() {
-                                        @NotNull
-                                        @Override
-                                        public JSONPair apply(Map.Entry<EntityType, Counter> entry) {
-                                            entityTypeSet.add(entry.getKey());
-                                            return pair(
-                                                    String.valueOf(entry.getKey().ordinal()),
-                                                    entry.getValue().count()
-                                            );
-                                        }
-                                    }
-                                ),
-                                toObjectMapper(input.tileEntityCounts.entrySet(),
-                                    new Function<Map.Entry<Material, Counter>, JSONPair>() {
-                                        @NotNull
-                                        @Override
-                                        public JSONPair apply(Map.Entry<Material, Counter> entry) {
-                                            tileEntityTypeSet.add(entry.getKey());
-                                            return pair(
-                                                    String.valueOf(entry.getKey().ordinal()),
-                                                    entry.getValue().count()
-                                            );
-                                        }
-                                    }
-                                )
-                            );
-                        }
-                    })
-                );
-            }
-        });
-    }
-    static class RegionData {
-        final RegionId regionId;
-        @SuppressWarnings("Guava")
-        static Function<RegionId, RegionData> LOADER = new Function<RegionId, RegionData>() {
-            @NotNull
-            @Override
-            public RegionData apply(@NotNull RegionId id) {
-                return new RegionData(id);
-            }
-        };
-        RegionData(@NotNull RegionId id) {
-            this.regionId = id;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-
-            RegionData that = (RegionData) o;
-
-            return regionId.equals(that.regionId);
-
-        }
-
-        @Override
-        public int hashCode() {
-            return regionId.hashCode();
-        }
-
-        @SuppressWarnings("unchecked")
-        final Map<EntityType, Counter> entityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<EntityType, Counter>(EntityType.class), k -> new Counter()
-        ));
-        @SuppressWarnings("unchecked")
-        final Map<Material, Counter> tileEntityCounts = MRUMapCache.of(LoadingMap.of(
-                new EnumMap<Material, Counter>(Material.class), k -> new Counter()
-        ));
-
-        static class RegionId {
-            final int x, z;
-            final long regionId;
-            RegionId(int x, int z) {
-                this.x = x >> 5 << 5;
-                this.z = z >> 5 << 5;
-                this.regionId = ((long) (this.x) << 32) + (this.z >> 5 << 5) - Integer.MIN_VALUE;
-            }
-
-            @Override
-            public boolean equals(Object o) {
-                if (this == o) return true;
-                if (o == null || getClass() != o.getClass()) return false;
-
-                RegionId regionId1 = (RegionId) o;
-
-                return regionId == regionId1.regionId;
-
-            }
-
-            @Override
-            public int hashCode() {
-                return (int) (regionId ^ (regionId >>> 32));
-            }
-        }
-    }
-    static void resetTicks(boolean fullReset) {
-        if (fullReset) {
-            // Non full is simply for 1 minute reports
-            timedTicks = 0;
-        }
-        lastMinuteTime = System.nanoTime();
-        playerTicks = 0;
-        tileEntityTicks = 0;
-        entityTicks = 0;
-        activatedEntityTicks = 0;
-    }
-
-    @NotNull
-    Object export() {
-        return createObject(
-            pair("s", startTime),
-            pair("e", endTime),
-            pair("tk", totalTicks),
-            pair("tm", totalTime),
-            pair("w", worlds),
-            pair("h", toArrayMapper(entries, new Function<TimingHistoryEntry, Object>() {
-                @Nullable
-                @Override
-                public Object apply(TimingHistoryEntry entry) {
-                    TimingData record = entry.data;
-                    if (!record.hasData()) {
-                        return null;
-                    }
-                    return entry.export();
-                }
-            })),
-            pair("mp", toArrayMapper(minuteReports, new Function<MinuteReport, Object>() {
-                @NotNull
-                @Override
-                public Object apply(MinuteReport input) {
-                    return input.export();
-                }
-            }))
-        );
-    }
-
-    static class MinuteReport {
-        final long time = System.currentTimeMillis() / 1000;
-
-        final TicksRecord ticksRecord = new TicksRecord();
-        final PingRecord pingRecord = new PingRecord();
-        final TimingData fst = TimingsManager.FULL_SERVER_TICK.minuteData.clone();
-        final double tps = 1E9 / ( System.nanoTime() - lastMinuteTime ) * ticksRecord.timed;
-        final double usedMemory = TimingsManager.FULL_SERVER_TICK.avgUsedMemory;
-        final double freeMemory = TimingsManager.FULL_SERVER_TICK.avgFreeMemory;
-        final double loadAvg = ManagementFactory.getOperatingSystemMXBean().getSystemLoadAverage();
-
-        @NotNull
-        List<Object> export() {
-            return toArray(
-                time,
-                Math.round(tps * 100D) / 100D,
-                Math.round(pingRecord.avg * 100D) / 100D,
-                fst.export(),
-                toArray(ticksRecord.timed,
-                    ticksRecord.player,
-                    ticksRecord.entity,
-                    ticksRecord.activatedEntity,
-                    ticksRecord.tileEntity
-                ),
-                usedMemory,
-                freeMemory,
-                loadAvg
-            );
-        }
-    }
-
-    private static class TicksRecord {
-        final long timed;
-        final long player;
-        final long entity;
-        final long tileEntity;
-        final long activatedEntity;
-
-        TicksRecord() {
-            timed = timedTicks - (TimingsManager.MINUTE_REPORTS.size() * 1200);
-            player = playerTicks;
-            entity = entityTicks;
-            tileEntity = tileEntityTicks;
-            activatedEntity = activatedEntityTicks;
-        }
-
     }
+    static void resetTicks(boolean fullReset) {}
 
-    private static class PingRecord {
-        final double avg;
-
-        PingRecord() {
-            final Collection<? extends Player> onlinePlayers = Bukkit.getOnlinePlayers();
-            int totalPing = 0;
-            for (Player player : onlinePlayers) {
-                totalPing += player.spigot().getPing();
-            }
-            avg = onlinePlayers.isEmpty() ? 0 : totalPing / onlinePlayers.size();
-        }
-    }
-
-
-    private static class Counter {
-        private int count = 0;
-        public int increment() {
-            return ++count;
-        }
-        public int count() {
-            return count;
-        }
-    }
 }
diff --git a/src/main/java/co/aikar/timings/Timings.java b/src/main/java/co/aikar/timings/Timings.java
index da76e1aaee1dee794e38ddd4e0a28e0071e90bbf..364d09c7fb2afc949e10bb35413d898bc50ba837 100644
--- a/src/main/java/co/aikar/timings/Timings.java
+++ b/src/main/java/co/aikar/timings/Timings.java
@@ -59,11 +59,7 @@ public final class Timings {
      */
     @NotNull
     public static Timing of(@NotNull Plugin plugin, @NotNull String name) {
-        Timing pluginHandler = null;
-        if (plugin != null) {
-            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
-        }
-        return of(plugin, name, pluginHandler);
+        return Timings.NULL_HANDLER;
     }
 
     /**
@@ -80,8 +76,7 @@ public final class Timings {
      */
     @NotNull
     public static Timing of(@NotNull Plugin plugin, @NotNull String name, @Nullable Timing groupHandler) {
-        Preconditions.checkNotNull(plugin, "Plugin can not be null");
-        return TimingsManager.getHandler(plugin.getName(), name, groupHandler);
+        return Timings.NULL_HANDLER;
     }
 
     /**
@@ -97,7 +92,7 @@ public final class Timings {
      */
     @NotNull
     public static Timing ofStart(@NotNull Plugin plugin, @NotNull String name) {
-        return ofStart(plugin, name, null);
+        return Timings.NULL_HANDLER;
     }
 
     /**
@@ -114,9 +109,7 @@ public final class Timings {
      */
     @NotNull
     public static Timing ofStart(@NotNull Plugin plugin, @NotNull String name, @Nullable Timing groupHandler) {
-        Timing timing = of(plugin, name, groupHandler);
-        timing.startTiming();
-        return timing;
+        return Timings.NULL_HANDLER;
     }
 
     /**
@@ -159,10 +152,7 @@ public final class Timings {
      *
      * @param enabled Should high-frequency timings be reported
      */
-    public static void setVerboseTimingsEnabled(boolean enabled) {
-        verboseEnabled = enabled;
-        TimingsManager.needsRecheckEnabled = true;
-    }
+    public static void setVerboseTimingsEnabled(boolean enabled) {}
 
     /**
      * <p>Gets the interval between Timing History report generation.</p>
@@ -215,24 +205,7 @@ public final class Timings {
      *
      * @param length Duration in ticks
      */
-    public static void setHistoryLength(int length) {
-        // Cap at 12 History Frames, 1 hour at 5 minute frames.
-        int maxLength = historyInterval * MAX_HISTORY_FRAMES;
-        // For special cases of servers with special permission to bypass the max.
-        // This max helps keep data file sizes reasonable for processing on Aikar's Timing parser side.
-        // Setting this will not help you bypass the max unless Aikar has added an exception on the API side.
-        if (System.getProperty("timings.bypassMax") != null) {
-            maxLength = Integer.MAX_VALUE;
-        }
-        historyLength = Math.max(Math.min(maxLength, length), historyInterval);
-        Queue<TimingHistory> oldQueue = TimingsManager.HISTORY;
-        int frames = (getHistoryLength() / getHistoryInterval());
-        if (length > maxLength) {
-            Bukkit.getLogger().log(Level.WARNING, "Timings Length too high. Requested " + length + ", max is " + maxLength + ". To get longer history, you must increase your interval. Set Interval to " + Math.ceil(length / MAX_HISTORY_FRAMES) + " to achieve this length.");
-        }
-        TimingsManager.HISTORY = EvictingQueue.create(frames);
-        TimingsManager.HISTORY.addAll(oldQueue);
-    }
+    public static void setHistoryLength(int length) {}
 
     /**
      * Resets all Timing Data
@@ -247,22 +220,14 @@ public final class Timings {
      * If sender is null, ConsoleCommandSender will be used.
      * @param sender The sender to send to, or null to use the ConsoleCommandSender
      */
-    public static void generateReport(@Nullable CommandSender sender) {
-        if (sender == null) {
-            sender = Bukkit.getConsoleSender();
-        }
-        requestingReport.add(sender);
-    }
+    public static void generateReport(@Nullable CommandSender sender) {}
 
     /**
      * Generates a report and sends it to the specified listener.
      * Use with {@link org.bukkit.command.BufferedCommandSender} to get full response when done!
      * @param sender The listener to send responses too.
      */
-    public static void generateReport(@NotNull TimingsReportListener sender) {
-        Validate.notNull(sender);
-        requestingReport.add(sender);
-    }
+    public static void generateReport(@NotNull TimingsReportListener sender) {}
 
     /*
     =================
@@ -272,16 +237,12 @@ public final class Timings {
     */
     @NotNull
     static TimingHandler ofSafe(@NotNull String name) {
-        return ofSafe(null, name, null);
+        return (TimingHandler) Timings.NULL_HANDLER;
     }
 
     @NotNull
     static Timing ofSafe(@Nullable Plugin plugin, @NotNull String name) {
-        Timing pluginHandler = null;
-        if (plugin != null) {
-            pluginHandler = ofSafe(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
-        }
-        return ofSafe(plugin != null ? plugin.getName() : "Minecraft - Invalid Plugin", name, pluginHandler);
+        return Timings.NULL_HANDLER;
     }
 
     @NotNull
diff --git a/src/main/java/co/aikar/timings/TimingsCommand.java b/src/main/java/co/aikar/timings/TimingsCommand.java
index f7c2245a310a084367ff25db539b3c967d5cb141..d03adfd56fca80f6737308f13d9c80d9dd06ff3c 100644
--- a/src/main/java/co/aikar/timings/TimingsCommand.java
+++ b/src/main/java/co/aikar/timings/TimingsCommand.java
@@ -49,71 +49,6 @@ public class TimingsCommand extends BukkitCommand {
 
     @Override
     public boolean execute(@NotNull CommandSender sender, @NotNull String currentAlias, @NotNull String[] args) {
-        if (!testPermission(sender)) {
-            return true;
-        }
-        if (args.length < 1) {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-            return true;
-        }
-        final String arg = args[0];
-        if ("on".equalsIgnoreCase(arg)) {
-            Timings.setTimingsEnabled(true);
-            sender.sendMessage("Enabled Timings & Reset");
-            return true;
-        } else if ("off".equalsIgnoreCase(arg)) {
-            Timings.setTimingsEnabled(false);
-            sender.sendMessage("Disabled Timings");
-            return true;
-        }
-
-        if (!Timings.isTimingsEnabled()) {
-            sender.sendMessage("Please enable timings by typing /timings on");
-            return true;
-        }
-
-        long now = System.currentTimeMillis();
-        if ("verbon".equalsIgnoreCase(arg)) {
-            Timings.setVerboseTimingsEnabled(true);
-            sender.sendMessage("Enabled Verbose Timings");
-            return true;
-        } else if ("verboff".equalsIgnoreCase(arg)) {
-            Timings.setVerboseTimingsEnabled(false);
-            sender.sendMessage("Disabled Verbose Timings");
-            return true;
-        } else if ("reset".equalsIgnoreCase(arg)) {
-            if (now - lastResetAttempt < 30000) {
-                TimingsManager.reset();
-                sender.sendMessage(ChatColor.RED + "Timings reset. Please wait 5-10 minutes before using /timings report.");
-            } else {
-                lastResetAttempt = now;
-                sender.sendMessage(ChatColor.RED + "WARNING: Timings v2 should not be reset. If you are encountering lag, please wait 3 minutes and then issue a report. The best timings will include 10+ minutes, with data before and after your lag period. If you really want to reset, run this command again within 30 seconds.");
-            }
-        } else  if (
-            "paste".equalsIgnoreCase(arg) ||
-                "report".equalsIgnoreCase(arg) ||
-                "get".equalsIgnoreCase(arg) ||
-                "merged".equalsIgnoreCase(arg) ||
-                "separate".equalsIgnoreCase(arg)
-            ) {
-            Timings.generateReport(sender);
-        } else {
-            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
-        }
         return true;
     }
-
-    @NotNull
-    @Override
-    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) {
-        Validate.notNull(sender, "Sender cannot be null");
-        Validate.notNull(args, "Arguments cannot be null");
-        Validate.notNull(alias, "Alias cannot be null");
-
-        if (args.length == 1) {
-            return StringUtil.copyPartialMatches(args[0], TIMINGS_SUBCOMMANDS,
-                new ArrayList<String>(TIMINGS_SUBCOMMANDS.size()));
-        }
-        return ImmutableList.of();
-    }
 }
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
index ef824d701c97cad8b31e76ad98c94fc4367a7eda..d7109fbe389ea05c288b00370fa3ab2489193bc2 100644
--- a/src/main/java/co/aikar/timings/TimingsManager.java
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -41,31 +41,8 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = LoadingMap.of(
-        new ConcurrentHashMap<>(4096, .5F), TimingHandler::new
-    );
-    public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
-    public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
-    public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
-    public static List<String> hiddenConfigs = new ArrayList<String>();
-    public static boolean privacy = false;
-
-    static final List<TimingHandler> HANDLERS = new ArrayList<>(1024);
-    static final List<TimingHistory.MinuteReport> MINUTE_REPORTS = new ArrayList<>(64);
-
-    static EvictingQueue<TimingHistory> HISTORY = EvictingQueue.create(12);
-    static long timingStart = 0;
-    static long historyStart = 0;
-    static boolean needsFullReset = false;
-    static boolean needsRecheckEnabled = false;
-
-    private TimingsManager() {}
-
-    /**
-     * Resets all timing data on the next tick
-     */
     static void reset() {
-        needsFullReset = true;
+
     }
 
     /**
@@ -73,66 +50,19 @@ public final class TimingsManager {
      * caused TPS loss.
      */
     static void tick() {
-        if (Timings.timingsEnabled) {
-            boolean violated = FULL_SERVER_TICK.isViolated();
-
-            for (TimingHandler handler : HANDLERS) {
-                if (handler.isSpecial()) {
-                    // We manually call this
-                    continue;
-                }
-                handler.processTick(violated);
-            }
-
-            TimingHistory.playerTicks += Bukkit.getOnlinePlayers().size();
-            TimingHistory.timedTicks++;
-            // Generate TPS/Ping/Tick reports every minute
-        }
     }
     static void stopServer() {
-        Timings.timingsEnabled = false;
-        recheckEnabled();
+
     }
     static void recheckEnabled() {
-        synchronized (TIMING_MAP) {
-            for (TimingHandler timings : TIMING_MAP.values()) {
-                timings.checkEnabled();
-            }
-        }
-        needsRecheckEnabled = false;
+
     }
     static void resetTimings() {
-        if (needsFullReset) {
-            // Full resets need to re-check every handlers enabled state
-            // Timing map can be modified from async so we must sync on it.
-            synchronized (TIMING_MAP) {
-                for (TimingHandler timings : TIMING_MAP.values()) {
-                    timings.reset(true);
-                }
-            }
-            Bukkit.getLogger().log(Level.INFO, "Timings Reset");
-            HISTORY.clear();
-            needsFullReset = false;
-            needsRecheckEnabled = false;
-            timingStart = System.currentTimeMillis();
-        } else {
-            // Soft resets only need to act on timings that have done something
-            // Handlers can only be modified on main thread.
-            for (TimingHandler timings : HANDLERS) {
-                timings.reset(false);
-            }
-        }
-
-        HANDLERS.clear();
-        MINUTE_REPORTS.clear();
-
-        TimingHistory.resetTicks(true);
-        historyStart = System.currentTimeMillis();
     }
 
     @NotNull
     static TimingHandler getHandler(@Nullable String group, @NotNull String name, @Nullable Timing parent) {
-        return TIMING_MAP.get(new TimingIdentifier(group, name, parent));
+        return new TimingHandler();
     }
 
 
@@ -147,23 +77,7 @@ public final class TimingsManager {
      */
     @NotNull
     public static Timing getCommandTiming(@Nullable String pluginName, @NotNull Command command) {
-        Plugin plugin = null;
-        final Server server = Bukkit.getServer();
-        if (!(  server == null || pluginName == null ||
-                "minecraft".equals(pluginName) || "bukkit".equals(pluginName) ||
-                "spigot".equalsIgnoreCase(pluginName) || "paper".equals(pluginName)
-        )) {
-            plugin = server.getPluginManager().getPlugin(pluginName);
-        }
-        if (plugin == null) {
-            // Plugin is passing custom fallback prefix, try to look up by class loader
-            plugin = getPluginByClassloader(command.getClass());
-        }
-        if (plugin == null) {
-            return Timings.ofSafe("Command: " + pluginName + ":" + command.getTimingName());
-        }
-
-        return Timings.ofSafe(plugin, "Command: " + pluginName + ":" + command.getTimingName());
+        return Timings.NULL_HANDLER;
     }
 
     /**
diff --git a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java b/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
deleted file mode 100644
index 632c4961515f5052551f841cfa840e60bba7a257..0000000000000000000000000000000000000000
--- a/src/main/java/co/aikar/timings/UnsafeTimingHandler.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * This file is licensed under the MIT License (MIT).
- *
- * Copyright (c) 2014 Daniel Ennis <http://aikar.co>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- */
-package co.aikar.timings;
-
-import org.bukkit.Bukkit;
-import org.jetbrains.annotations.NotNull;
-
-class UnsafeTimingHandler extends TimingHandler {
-
-    UnsafeTimingHandler(@NotNull TimingIdentifier id) {
-        super(id);
-    }
-
-    private static void checkThread() {
-        if (!Bukkit.isPrimaryThread()) {
-            throw new IllegalStateException("Calling Timings from Async Operation");
-        }
-    }
-
-    @NotNull
-    @Override
-    public Timing startTiming() {
-        checkThread();
-        return super.startTiming();
-    }
-
-    @Override
-    public void stopTiming() {
-        checkThread();
-        super.stopTiming();
-    }
-}
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index 460fda05a62b12db2edcfb7ea8b2a5dd8e4b110d..c03f01f9eda297dedbcbd54b2f40d66b85313c7f 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -38,7 +38,6 @@ public class SimpleCommandMap implements CommandMap {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
         register("bukkit", new PluginsCommand("plugins"));
-        register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Paper
     }
 
     public void setFallbackCommands() {
